Parse parameters
	Check if it's a flag
		If so, change smth in flags structure
			(after flag there has to be an argument (sometimes)

	If not, then probably it's a bot
		Try opening this file and read 0 bytes from it
			On success, put it's fd into the array
				If array is full, ERROR

		If cannot open, ERROR

Initialize
	Initialize arena

	Read bots and check them
		Go through an array of fds
			For every fd read code from it into the buffer
				Check the code

					COR_MAX_LEN = 4 + PROG_NAME_LENGTH + 4 + 4 + COMMENT_LENGTH + 4 + CHAMP_MAX_SIZE
					
					Make arrays with COR_MAX_LEN bytes and use read(fd, arr, COR_MAX_LEN + 1). If read returns more then COR_MAX_LEN, it's error.
					Check if first 4 bytes are "corewar magic number", if not - it's error
					Check next PROG_NAME_LENGTH bytes. There must be name. If there isn't - error
					Next 4 bytes must be NULL
					There must be size of executable code. CODE_SIZE = size of executable code
					COMMENT_LENGTH bytes must have comment inside
					4 bytes for NULL
					read next CODE_SIZE bytes. If array ends there - error

					On error ERROR

				If all's ok, write it on arena(we can calculate the position of the bot)
					Initialize a carriage for a bot(put it into stack or queue or whatever)

Pray

Play (repeat)
	Carriages action
		Go through carriages stack(queue(whatever))
			For every carriage determine operation, parameters
				If it's counter is bigger than zero, decrement it
				Else execute them
					What function's do?
					[
						live:
						{
							Gives a life to carriage and to player, which number is in functions argument.
							NUMBERS OF PLAYERS: 1. ffffff, 2. fffffe, 3. fffffd, 4.fffffc
						}
						ld:
						{
							Writes data from 1st arg to REGISTER (2nd arg).
							If 1st arg is T_DIR, just copies it to 2nd arg, else if 1st arg is T_IND, data copies from 4 bytes, starting from adress PC + (1st arg % IDX_MOD).
							This function changes carry. If it wrote 0 to 2nd arg, carry becomes 1, in other cases carry becomes 0.
						}
						st
						{
							Writes data from 1st arg (T_REG) to 2nd arg (T_REG or T_IND). If 2nd arg is T_REG, just copies data from 1st arg to 2nd
							 else if 2nd arg is T_IND, data copies to 4 bytes, starting from adress PC + (1st arg % IDX_MOD)
						}
						add
						{
							Writes (1st arg + 2nd arg) to 3rd arg. All args have type T_REG.
							This function changes carry. If it wrote 0 to 3rd arg, carry becomes 1, in other cases carry becomes 0.
						}
						sub
						{
							Writes (1st arg - 2nd arg) to 3rd arg. All args have type T_REG.
							This function changes carry. If it wrote 0 to 3rd arg, carry becomes 1, in other cases carry becomes 0.
						}
						and
						{
							Writes (1st arg & 2nd arg) to 3rd arg. All args have type T_REG.
							This function changes carry. If it wrote 0 to 3rd arg, carry becomes 1, in other cases carry becomes 0.
						}
						or
						{
							Writes (1st arg | 2nd arg) to 3rd arg. All args have type T_REG.
							This function changes carry. If it wrote 0 to 3rd arg, carry becomes 1, in other cases carry becomes 0.
						}
						xor
						{
							Writes (1st arg ^ 2nd arg) to 3rd arg. All args have type T_REG.
							This function changes carry. If it wrote 0 to 3rd arg, carry becomes 1, in other cases carry becomes 0.
						}
						zjmp
						{
							Changes position of this carriage to (1st arg % IDX_MOD) if (carry == 0)
						}
						ldi
						{
							If 1st arg is NOT T_IND: writes data from 4 bytes, starting from address ((1st arg + 2nd arg) % IDX_MOD + PC) to 3rd arg (T_REG)
							Else if 1st arg is T_IND : writes data from 4 bytes, starting from address (((4 bytes starting from (1st arg % IDX_MOD + PC)) + 2nd arg) % IDX_MOD + PC)
						}
						sti
						{
							Writes 1st arg (T_REG) to 4 bytes, starting with adress:
							If 2nd arg is NOT T_IND: ((2nd arg + 3rd arg) % IDX_MOD + PC)
							Else if 2nd arg is T_IND: (((4 bytes starting from (2nd arg % IDX_MOD)) + 3rd arg) % IDX_MOD + PC)
						}
						fork
						{
							Make a copy of this carry with all it's parameters except PC. Copy will have new PC: (T_IND % IDX_MOD + old PC)
						}
						lld
						{
							Writes data from 1st arg to REGISTER (2nd arg).
							If 1st arg is T_DIR, just copies it to 2nd arg, else if 1st arg is T_IND, data copies from 2 bytes, starting from adress (1st arg + PC).
							This function changes carry. If it wrote 0 to 2nd arg, carry becomes 1, in other cases carry becomes 0.
						}
						lldi
						{
							If 1st arg is NOT T_IND: writes data from 4 bytes, starting from address ((1st arg + 2nd arg) + PC) to 3rd arg (T_REG)
							Else if 1st arg is T_IND : writes data from 4 bytes, starting from address (((4 bytes starting from (1st arg % IDX_MOD + PC)) + 2nd arg) + PC)
							This function changes carry. If it wrote 0 to 3rd arg, carry becomes 1, in other cases carry becomes 0.
						}
						lfork
						{
							Make a copy of this carry with all it's parameters except PC. Copy will have new PC: (T_IND + old PC)
						}
						aff
						{
							If corewar executed with '-a' option:
							 prints (1st arg % 256) as ascii symbol on stdout
							Else do nothing
						}
					]

	If there is output flag, call the output function, pass there a flag and a structure
		In that function call the appropriate ouput function(ncurses, output, sfml)

	If Cycle > Cycle_to_die
		Check players
			If player hasn't said "live" for 2 cycles - mark him as dead
			
			If there r no players alive, end

		Check carriages
			If carriage hasn't said "live" for 2 cycles - delete it from stack(heap(tree(queue(list(whatever)))))

...

Rules:
1: Never use t_info, use t_data
2: Always obey rule 1
3: And rule 2

vim:fdm=indent ts=2 sw=2
